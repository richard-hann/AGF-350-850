
clear
clc
close all

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ------------------------- READING DATA FROM THE HOBO AWS -----------------------------%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Auto-generated by MATLAB on 2019/09/08 17:32:38
% script modified by Marius

%% INPUT: BEFORE RUNNING SCRIPT, MAKE SURE THAT THE PATH TO THE DATA IS CORRECT IN THE FILE set_filepaths.m

% Make sure that the wind direction correction at the bottom of the script is done correctly

% Make sure that the start- and end-time for the 30min are set correctly 



[filepath,~,~] = fileparts(mfilename('fullpath'));
cd(filepath)

run ./../set_filepaths
addpath(genpath(toolboxpath))



for qq = 1
    
    if qq == 1
        cd(AWS_Hobo_1_path)
    elseif qq == 2
        cd(AWS_Hobo_2_path)
    end

    fn = dir('*.txt');

    % preparing structure "hobo" for parameter input 
AWS_HOBO(qq).time  = []; % time
AWS_HOBO(qq).WS_1  = []; % wind speed at lower level
AWS_HOBO(qq).WSg_1 = []; % wind gust at lower level
AWS_HOBO(qq).T_1   = []; % temperature at lower level
AWS_HOBO(qq).RH_1  = []; % relative humidity at lower level
AWS_HOBO(qq).sol_1 = []; % solar radiation
AWS_HOBO(qq).T_2   = []; % temperature at upper level
AWS_HOBO(qq).RH_2  = []; % relative humidity at upper level
AWS_HOBO(qq).P     = []; % air pressure
AWS_HOBO(qq).WD_2  = []; % wind direction at upper level
AWS_HOBO(qq).WS_2  = []; % wind speed at upper level
AWS_HOBO(qq).WSg_2 = []; % wind gust at upper level
AWS_HOBO(qq).sol_2 = []; % solar radiation


for qz = 1:length(fn)

    filename = char(fn(qz).name);
    
delimiter = ';';
startRow = 3;

% Read columns of data as text:
% For more information, see the TEXTSCAN documentation.

if qq == 1
    formatSpec = '%q%q%q%q%q%q%q%q%q%q%q%q%q%q%q%q%[^\n\r]';
elseif qq == 2
    formatSpec = '%q%q%q%q%q%q%q%q%q%q%q%q%q%q%[^\n\r]';
end

% Open the text file.
fileID = fopen(filename,'r');

% Read columns of data according to the format.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'TextType', 'string', 'HeaderLines' ,startRow-1, 'ReturnOnError', false, 'EndOfLine', '\r\n');

% Close the text file.
fclose(fileID);

% Convert the contents of columns containing numeric text to numbers.
% Replace non-numeric text with NaN.
raw = repmat({''},length(dataArray{1}),length(dataArray)-1);
for col=1:length(dataArray)-1
    raw(1:length(dataArray{col}),col) = mat2cell(dataArray{col}, ones(length(dataArray{col}), 1));
end
numericData = NaN(size(dataArray{1},1),size(dataArray,2));

if qq == 1
    cols = [1,3,4,5,6,7,8,9,10,11,12,13,14,15,16];
elseif qq == 2
    cols = [1,3,4,5,6,7,8,9,10,11,12,13,14];
end

for col=cols
    % Converts text in the input cell array to numbers. Replaced non-numeric
    % text with NaN.
    rawData = dataArray{col};
    for row=1:size(rawData, 1)
        % Create a regular expression to detect and remove non-numeric prefixes and
        % suffixes.
        regexstr = '(?<prefix>.*?)(?<numbers>([-]*(\d+[\,]*)+[\.]{0,1}\d*[eEdD]{0,1}[-+]*\d*[i]{0,1})|([-]*(\d+[\,]*)*[\.]{1,1}\d+[eEdD]{0,1}[-+]*\d*[i]{0,1}))(?<suffix>.*)';
        try
            result = regexp(rawData(row), regexstr, 'names');
            numbers = result.numbers;
            
            % Detected commas in non-thousand locations.
            invalidThousandsSeparator = false;
            if numbers.contains(',')
                thousandsRegExp = '^[-/+]*\d+?(\,\d{3})*\.{0,1}\d*$';
                if isempty(regexp(numbers, thousandsRegExp, 'once'))
                    numbers = NaN;
                    invalidThousandsSeparator = true;
                end
            end
            % Convert numeric text to numbers.
            if ~invalidThousandsSeparator
                numbers = textscan(char(strrep(numbers, ',', '')), '%f');
                numericData(row, col) = numbers{1};
                raw{row, col} = numbers{1};
            end
        catch
            raw{row, col} = rawData{row};
        end
    end
end


% Split data into numeric and string columns.
if qq == 1
    rawNumericColumns = raw(:, [1,3,4,5,6,7,8,9,10,11,12,13,14,15,16]);
elseif qq == 2
    rawNumericColumns = raw(:, [1,3,4,5,6,7,8,9,10,11,12,13,14]);
end
rawStringColumns = string(raw(:, 2));


% Replace non-numeric cells with NaN
R = cellfun(@(x) ~isnumeric(x) && ~islogical(x),rawNumericColumns); % Find non-numeric cells
rawNumericColumns(R) = {NaN}; % Replace non-numeric cells


% Create output variable

if qq == 1
    HOBOdata = table;
    HOBOdata.VarName1 = cell2mat(rawNumericColumns(:, 1));
    HOBOdata.DateTimeGMT0000 = rawStringColumns(:, 1);
    HOBOdata.WindSpeed_1 = cell2mat(rawNumericColumns(:, 2));
    HOBOdata.GustSpeed_1 = cell2mat(rawNumericColumns(:, 3));
    HOBOdata.Temp_1 = cell2mat(rawNumericColumns(:, 4));
    HOBOdata.RH_1 = cell2mat(rawNumericColumns(:, 5));
    HOBOdata.SolarRadiation_1 = cell2mat(rawNumericColumns(:, 6));
    HOBOdata.Temp_2 = cell2mat(rawNumericColumns(:, 7));
    HOBOdata.RH_2 = cell2mat(rawNumericColumns(:, 8));
    HOBOdata.Pressure = cell2mat(rawNumericColumns(:, 9));
    HOBOdata.WindDirection_2 = cell2mat(rawNumericColumns(:, 10));
    HOBOdata.WindSpeed_2 = cell2mat(rawNumericColumns(:, 11));
    HOBOdata.GustSpeed_2 = cell2mat(rawNumericColumns(:, 12));
    HOBOdata.SolarRadiation_2 = cell2mat(rawNumericColumns(:, 13));
    HOBOdata.Voltage = cell2mat(rawNumericColumns(:, 14));
    HOBOdata.Current = cell2mat(rawNumericColumns(:, 15));
elseif qq == 2
    HOBOdata = table;
    HOBOdata.DateTimeGMT0000 = rawStringColumns(:, 1);
%     HOBOdata.VarName1 = cell2mat(rawNumericColumns(:, 1));
    HOBOdata.SolarRadiation_1 = cell2mat(rawNumericColumns(:, 2));
    HOBOdata.Pressure = cell2mat(rawNumericColumns(:, 3));
    HOBOdata.WindSpeed_1 = cell2mat(rawNumericColumns(:, 4));
    HOBOdata.GustSpeed_1 = cell2mat(rawNumericColumns(:, 5));
    HOBOdata.Temp_1 = cell2mat(rawNumericColumns(:, 6));
    HOBOdata.RH_1 = cell2mat(rawNumericColumns(:, 7));
    HOBOdata.WindDirection_2 = cell2mat(rawNumericColumns(:, 8));
    HOBOdata.SolarRadiation_2 = cell2mat(rawNumericColumns(:, 9));
    HOBOdata.Temp_2 = cell2mat(rawNumericColumns(:, 10));
    HOBOdata.RH_2 = cell2mat(rawNumericColumns(:, 11));
    HOBOdata.WindSpeed_2 = cell2mat(rawNumericColumns(:, 12));
    HOBOdata.GustSpeed_2 = cell2mat(rawNumericColumns(:, 13));
end


time  = datenum(HOBOdata.DateTimeGMT0000,'mm.dd.yy HH:MM:SS');
WS_1  = HOBOdata.WindSpeed_1;
WSg_1 = HOBOdata.GustSpeed_1;
T_1   = HOBOdata.Temp_1;
RH_1  = HOBOdata.RH_1;
sol_1 = HOBOdata.SolarRadiation_1;
T_2   = HOBOdata.Temp_2;
RH_2  = HOBOdata.RH_2;
P     = HOBOdata.Pressure;
WD_2  = HOBOdata.WindDirection_2;
WS_2  = HOBOdata.WindSpeed_2;
WSg_2 = HOBOdata.GustSpeed_2;
sol_2 = HOBOdata.SolarRadiation_2;


% Concatenating (putting together) data from each of the data files
AWS_HOBO(qq).time     = [AWS_HOBO(qq).time(:)' time(:)'];
AWS_HOBO(qq).WS_1     = [AWS_HOBO(qq).WS_1(:)' WS_1(:)'];
AWS_HOBO(qq).WSg_1    = [AWS_HOBO(qq).WSg_1(:)' WSg_1(:)'];
AWS_HOBO(qq).T_1      = [AWS_HOBO(qq).T_1(:)' T_1(:)'];
AWS_HOBO(qq).RH_1     = [AWS_HOBO(qq).RH_1(:)' RH_1(:)'];
AWS_HOBO(qq).sol_1    = [AWS_HOBO(qq).sol_1(:)' sol_1(:)'];
AWS_HOBO(qq).T_2      = [AWS_HOBO(qq).T_2(:)' T_2(:)'];
AWS_HOBO(qq).RH_2     = [AWS_HOBO(qq).RH_2(:)' RH_2(:)'];
AWS_HOBO(qq).P        = [AWS_HOBO(qq).P(:)' P(:)'];
AWS_HOBO(qq).WD_2     = [AWS_HOBO(qq).WD_2(:)' WD_2(:)'];
AWS_HOBO(qq).WS_2     = [AWS_HOBO(qq).WS_2(:)' WS_2(:)'];
AWS_HOBO(qq).WSg_2    = [AWS_HOBO(qq).WSg_2(:)' WSg_2(:)'];
AWS_HOBO(qq).sol_2    = [AWS_HOBO(qq).sol_2(:)' sol_2(:)'];


% Sorting data from the files in case they are not in the right order
    [a b] = sort(AWS_HOBO(qq).time);
AWS_HOBO(qq).time   = AWS_HOBO(qq).time(b);
AWS_HOBO(qq).WS_1   = AWS_HOBO(qq).WS_1(b);
AWS_HOBO(qq).WSg_1  = AWS_HOBO(qq).WSg_1(b);
AWS_HOBO(qq).T_1    = AWS_HOBO(qq).T_1(b);
AWS_HOBO(qq).RH_1   = AWS_HOBO(qq).RH_1(b);
AWS_HOBO(qq).sol_1  = AWS_HOBO(qq).sol_1(b);
AWS_HOBO(qq).T_2    = AWS_HOBO(qq).T_2(b);
AWS_HOBO(qq).RH_2   = AWS_HOBO(qq).RH_2(b);
AWS_HOBO(qq).P      = AWS_HOBO(qq).P(b);
AWS_HOBO(qq).WD_2   = AWS_HOBO(qq).WD_2(b);
AWS_HOBO(qq).WS_2   = AWS_HOBO(qq).WS_2(b);
AWS_HOBO(qq).WSg_2  = AWS_HOBO(qq).WSg_2(b);
AWS_HOBO(qq).sol_2  = AWS_HOBO(qq).sol_2(b);

end


% CALCULATING POTENTIAL TEMPERATURE AND SPECIFIC HUMIDITY

AWS_HOBO(qq).TP_1 = calc_pot_temp(AWS_HOBO(qq).T_1,AWS_HOBO(qq).P);
AWS_HOBO(qq).TP_2 = calc_pot_temp(AWS_HOBO(qq).T_2,AWS_HOBO(qq).P);

AWS_HOBO(qq).Q_1 = calc_spec_humid(AWS_HOBO(qq).T_1,AWS_HOBO(qq).RH_1,AWS_HOBO(qq).P);
AWS_HOBO(qq).Q_2 = calc_spec_humid(AWS_HOBO(qq).T_2,AWS_HOBO(qq).RH_2,AWS_HOBO(qq).P);


 % INPUT: AVERAGING DATA IN 30 MIN INTERVALS
    %   NB! set the start- and -end-points of the time vector correctly
    start30 = datenum('11-Feb-2020 00:00:00');
    end30   = datenum('16-Feb-2020 00:00:00');
    t30min  = (start30-0.25/24):0.5/24:(end30+0.25/24);


    AWS_HOBO(qq).time_30min = start30:0.5/24:end30;
    
%     qq = 1;
    
    for i = 1:length(t30min)-1
        id = find(AWS_HOBO(qq).time >= t30min(i) & AWS_HOBO(qq).time <= t30min(i+1));
        
        AWS_HOBO(qq).WS_1_30min(i)  = nanmean(AWS_HOBO(qq).WS_1(id));
        AWS_HOBO(qq).WSg_1_30min(i) = nanmean(AWS_HOBO(qq).WSg_1(id));
        AWS_HOBO(qq).T_1_30min(i)   = nanmean(AWS_HOBO(qq).T_1(id));
        AWS_HOBO(qq).RH_1_30min(i)  = nanmean(AWS_HOBO(qq).RH_1(id));
        AWS_HOBO(qq).sol_1_30min(i) = nanmean(AWS_HOBO(qq).sol_1(id));
        AWS_HOBO(qq).P_30min(i)     = nanmean(AWS_HOBO(qq).P(id));
        AWS_HOBO(qq).WS_2_30min(i)  = nanmean(AWS_HOBO(qq).WS_2(id));
        AWS_HOBO(qq).WSg_2_30min(i) = nanmean(AWS_HOBO(qq).WSg_2(id));
        AWS_HOBO(qq).T_2_30min(i)   = nanmean(AWS_HOBO(qq).T_2(id));
        AWS_HOBO(qq).RH_2_30min(i)  = nanmean(AWS_HOBO(qq).RH_2(id));
        AWS_HOBO(qq).sol_2_30min(i) = nanmean(AWS_HOBO(qq).sol_2(id));
        AWS_HOBO(qq).Q_1_30min(i)   = nanmean(AWS_HOBO(qq).Q_1(id));
        AWS_HOBO(qq).Q_2_30min(i)   = nanmean(AWS_HOBO(qq).Q_2(id));
        AWS_HOBO(qq).TP_1_30min(i)  = nanmean(AWS_HOBO(qq).TP_1(id));
        AWS_HOBO(qq).TP_2_30min(i)  = nanmean(AWS_HOBO(qq).TP_2(id));
        
            a   = AWS_HOBO(qq).WD_2(id)';
            aa  = circ_ang2rad(a);
            am  = circ_mean(aa);
            amm = circ_rad2ang(am);
            a2  = mod(amm,360);
        AWS_HOBO(qq).WD_2_30min(i) = a2;

    end
    
    
    % CORRECTING OFFSET IN WIND DIRECTION FROM TRUE NORTH
    %   Based on notes and magnetic declination of 10 degrees
   
    if qq == 1
%         AWS_HOBO(qq).WD_1 = mod(AWS_HOBO(qq).WD_1 - 85 - 10,360);
        AWS_HOBO(qq).WD_2       = mod(AWS_HOBO(qq).WD_2 + 85 + 10,360);
        AWS_HOBO(qq).WD_2_30min = mod(AWS_HOBO(qq).WD_2_30min + 85 + 10,360);
    elseif qq == 2
%         AWS_HOBO(qq).WD_1 = mod(AWS_HOBO(qq).WD_1 - 121 - 10,360);
        AWS_HOBO(qq).WD_2       = mod(AWS_HOBO(qq).WD_2 - 121 + 10,360);
        AWS_HOBO(qq).WD_2_30min = mod(AWS_HOBO(qq).WD_2_30min - 121 + 10,360);
    end
    
    
end

    
clearvars -except AWS*

disp(['-----------------------------------'])
disp([' Done reading files from HOBO AWS  '])
disp(['-----------------------------------'])


